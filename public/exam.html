<script>
(() => {
  const qs = (sel, el = document) => el.querySelector(sel);
  const qsa = (sel, el = document) => [...el.querySelectorAll(sel)];
  const fmt = (n) => String(n).padStart(2, '0');

  // UI
  const chips = qsa('[data-preset]');                 // chips: PAA/PCA/PCG
  const diffSel = qs('#diffSelect') || qs('select[name="difficulty"]');
  const countInput = qs('#countPerSection') || qs('input[name="countPerSection"]');
  const generateBtn = qs('#btnGenerate') || qs('button[data-generate]');
  const totalTimeEl = qs('[data-total]');
  const remainingEl = qs('[data-remaining]');
  const panel = qs('#examPanel') || qs('[data-exam-panel]');
  const msgBox = qs('#examMsg') || qs('[data-exam-msg]');

  let mode = new URLSearchParams(location.search).get('mode') || 'paa';
  let timerId = null;
  let deadline = null;

  // Presets oficiales
  const PRESETS = {
    paa: { label: 'PAA',  sections: 2, time: 120, count: 30, topics: ['algebra','lectura'] }, // 30+30
    pca: { label: 'PCA',  sections: 2, time: 120, count: 50, topics: ['lectura','algebra'] }, // 50+50 (español->lectura)
    pcg: { label: 'PCG',  sections: 4, time: 120, count: 25, topics: ['biologia','quimica','fisica','algebra'] }, // 25×4
  };

  // ---------- helpers ----------
  function showMsg(text, tone = 'info') {
    if (!msgBox) return;
    msgBox.innerHTML = text;
    msgBox.className = ''; // reset
    msgBox.classList.add('msg', tone); // .msg.info/.msg.warn/.msg.error
  }
  function clearMsg() {
    if (!msgBox) return;
    msgBox.innerHTML = '';
    msgBox.className = 'msg';
  }
  function resetTimer() {
    if (timerId) clearInterval(timerId);
    timerId = null; deadline = null;
    if (remainingEl) remainingEl.textContent = '—';
  }
  function startTimer(mins) {
    resetTimer();
    deadline = Date.now() + mins*60*1000;
    timerId = setInterval(() => {
      const left = Math.max(0, deadline - Date.now());
      const m = Math.floor(left/60000), s = Math.floor((left%60000)/1000);
      if (remainingEl) remainingEl.textContent = `${fmt(m)}:${fmt(s)}`;
      if (left <= 0) { clearInterval(timerId); timerId = null; }
    }, 250);
  }
  function setPreset(newMode) {
    mode = newMode;
    const p = PRESETS[mode];
    if (totalTimeEl) totalTimeEl.textContent = `${fmt(p.time)}:00`;
    if (countInput) countInput.value = p.count; // por defecto oficial (si falta banco, mostraremos error)
    // Marca chip activo visualmente
    chips.forEach(c => c.classList.toggle('active', c.dataset.preset === mode));
  }

  // Render
  function renderExam(sections) {
    if (!panel) return;
    const html = sections.map((sec, idx) => {
      const qhtml = sec.questions.map((q, i) => {
        const opts = q.choices.map((c, j) => `
          <label class="opt">
            <input type="radio" name="q-${sec.key}-${i}" value="${j}"> <span>${c}</span>
          </label>
        `).join('');
        return `
          <div class="q-card">
            <div class="q-title">${i+1}. ${q.prompt}</div>
            <div class="q-opts">${opts}</div>
          </div>
        `;
      }).join('');
      return `
        <section class="sec">
          <div class="sec-head">
            <h3>${sec.title}</h3>
            <span class="pill">${sec.questions.length} preguntas</span>
          </div>
          ${qhtml}
        </section>
      `;
    }).join('');
    panel.innerHTML = html;
  }

  // Llamada al backend
  async function generateExam() {
    clearMsg();
    if (!PRESETS[mode]) setPreset('paa');

    const p = PRESETS[mode];
    const difficulty = (diffSel && diffSel.value) || 'medium';
    const count = parseInt((countInput && countInput.value) || `${p.count}`, 10) || p.count;

    // Petición simple al endpoint unificado
    let resp;
    try {
      resp = await fetch('/api/generate-exam', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({
          mode,
          difficulty,
          count_per_section: count
        })
      });
    } catch (e) {
      showMsg('Error de red. Verifica tu conexión o tu despliegue.', 'error');
      return;
    }

    let data;
    try { data = await resp.json(); } catch {
      showMsg('Respuesta no válida del servidor. Revisa logs de Vercel.', 'error');
      return;
    }

    if (!data.ok) {
      // Mensajes claros cuando falta banco
      if (data.error === 'INSUFFICIENT_BANK') {
        const need = count;
        showMsg(`
          <b>Banco insuficiente</b> para <b>${p.label}</b>.<br>
          • Intenta bajar “Preguntas por sección” (ej., 8).<br>
          • O agrega más preguntas con SQL (recomendado).<br>
          <small>Detalle: ${data.detail || ''}</small>
        `, 'warn');
      } else {
        showMsg(`No se pudo generar el examen: ${data.error || 'Error'}`, 'error');
      }
      return;
    }

    // Render & timer
    renderExam(data.sections || []);
    if (totalTimeEl) totalTimeEl.textContent = `${fmt(p.time)}:00`;
    startTimer(p.time);
    showMsg(`${p.label} listo. ¡Éxitos!`, 'info');
  }

  // Eventos
  chips.forEach(chip => {
    chip.addEventListener('click', () => {
      setPreset(chip.dataset.preset);
      // Preajustar el count oficial, pero no generamos aún para que el usuario vea el valor
      const p = PRESETS[mode];
      if (countInput) countInput.value = p.count;
      clearMsg(); resetTimer(); panel && (panel.innerHTML = '');
      // Auto-intento: si quieres que dispare de una, descomenta:
      // generateExam();
    });
  });
  generateBtn && generateBtn.addEventListener('click', generateExam);

  // Inicializa por query param:
  setPreset(mode);
})();
</script>



